archetype tzombies

/* TOKEN METADATA ------------------------------------------------------------ */

asset token_metadata to big_map {
  ftoken_metadata : nat;
  token_id        : nat;
  token_info      : map<string, bytes>;
}

/* ERRORS ----------------------------------------------------------------- */

constant CALLER_NOT_OWNER         : string = "CALLER_NOT_OWNER"
constant FA2_INSUFFICIENT_BALANCE : string = "FA2_INSUFFICIENT_BALANCE"
constant FA2_NOT_OPERATOR         : string = "FA2_NOT_OPERATOR"
constant FA2_NOT_OWNER            : string = "FA2_NOT_OWNER"
constant FA2_TOKEN_UNDEFINED      : string = "FA2_TOKEN_UNDEFINED"

/* PARAMETERS ------------------------------------------------------------- */

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
} as ((%to_, (token_id, amount)))

record transfer_param {
  tp_from : address;
  tp_txs  : list<transfer_destination>;
} as ((%from_, %txs))

/* STORAGE ---------------------------------------------------------------- */

variable registered: list<nat> = []

asset ledger identified by lowner ltokenid to big_map {
  lowner     : address;
  ltokenid   : nat;
  lamount    : nat = 0;
}

asset operator identified by oaddr otoken oowner to big_map {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
}

asset operator_for_all identified by fa_oaddr fa_oowner to big_map {
  fa_oaddr    : address;
  fa_oowner   : address;
}

/* ENTRYPOINTS ------------------------------------------------------------- */

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

enum update_op =
| add_operator<operator_param>
| remove_operator<operator_param>

entry update_operators (upl : list<update_op>) {
  no transfer
  effect {
    for up in upl do
      match up with
      | add_operator(param) -> (* add *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.put({param.opp_operator; param.opp_token_id; param.opp_owner})
      | remove_operator(param) -> (* remove *)
        do_require(param.opp_owner = caller , FA2_NOT_OWNER);
        operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
      end;
    done;
  }
}

enum update_for_all_op =
| add_for_all<address>
| remove_for_all<address>

entry update_operators_for_all (upl : list<update_for_all_op>) {
  effect {
    for up in upl do
      match up with
      | add_for_all(op)  ->
          operator_for_all.put({ op; caller })
      | remove_for_all(op) ->
          operator_for_all.remove((op, caller))
      end;
    done;
  }
}

entry %transfer (txs : list<transfer_param>) {
  effect {
    for tx in txs do
      const %from = tx.tp_from;
      const tds = tx.tp_txs;
      for td in tds do begin
        const tid = td.token_id_dest;
        do_require(
          %from = caller or
          operator.contains((caller, tid, %from)) or
          operator_for_all.contains((caller, %from)),
          FA2_NOT_OPERATOR
        );
        const amount = ledger[(%from, tid)]?.lamount ? the : 0;
        const new_amount ?=
            int_to_nat(amount - td.token_amount_dest) : FA2_INSUFFICIENT_BALANCE;
        if new_amount = 0 then
          ledger.remove((%from, tid))
        else begin
          ledger.update((%from, tid), { lamount := new_amount });
        end;
        ledger.add_update((td.to_dest, tid), { lamount += td.token_amount_dest })
      end done
    done
  }
}

entry register(id: nat, info: map<string, bytes>) {
  effect {
    token_metadata.add({
      ftoken_metadata = id;
      token_id        = id;
      token_info      = info
    });
    registered.prepend(id);
  }
}

entry mint (id: nat) {
  require {
    r1: token_metadata.contains(id);
  }
  effect {
    ledger.add_update((caller, id), { lamount += 1 });
  }
}

/* GETTERS ----------------------------------------------------------------- */

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
} as ((owner, token_id))

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
} as ((request, balance))

function get_balance(br : balance_of_request) : nat {
  do_require(token_metadata.contains(br.btoken_id), FA2_TOKEN_UNDEFINED);
  return (ledger[(br.bo_owner, br.btoken_id)] ? the.lamount : 0)
}

getter balance_of (requests : list<balance_of_request>) : list<balance_of_response> {
  return map(requests, br ->
    {
      request = br;
      balance_ = get_balance(br)
    })
}